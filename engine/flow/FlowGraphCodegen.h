#pragma once
#include "FlowGraphIR.h"
#include <string>
#include <sstream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>

namespace atlas::flow {

// --- FlowGraphCodegen: converts FlowGraphIR to standalone C++ source ---

class FlowGraphCodegen {
public:
    /// Generate C++ source from a compiled flow graph IR.
    static std::string Generate(const FlowGraphIR& ir) {
        std::ostringstream out;

        // --- Header / preamble ---
        out << "// Generated by AtlasForge FlowGraphCodegen\n";
        out << "// Graph: \"" << ir.name << "\" (" << ir.graphType << ")\n";
        out << "#include <vector>\n";
        out << "#include <string>\n";
        out << "#include <cstdint>\n";
        out << "#include <unordered_map>\n";
        out << "\n";

        // --- Support structs ---
        out << "struct FlowValue {\n";
        out << "    std::vector<float> data;\n";
        out << "    std::string text;\n";
        out << "};\n\n";

        out << "struct FlowContext {\n";
        out << "    float elapsedTime;\n";
        out << "    bool inputReceived;\n";
        out << "    uint32_t tick;\n";
        out << "};\n\n";

        // --- Sanitize graph name for function identifier ---
        std::string funcName = SanitizeName(ir.name);

        // --- Function signature ---
        out << "void Execute_" << funcName << "(const FlowContext& ctx,\n";
        out << "                     std::unordered_map<uint64_t, FlowValue>& outputs) {\n";

        if (ir.nodes.empty()) {
            out << "    // Empty graph â€” nothing to execute\n";
            out << "}\n";
            return out.str();
        }

        // --- Topological sort ---
        std::vector<uint32_t> sorted = TopologicalSort(ir);

        // --- Build edge lookup: toNode -> list of (fromNode, fromPort, toPort) ---
        std::unordered_map<uint32_t, std::vector<FlowEdge>> incomingEdges;
        for (const auto& e : ir.edges) {
            incomingEdges[e.toNode].push_back(e);
        }

        // --- Build node lookup ---
        std::unordered_map<uint32_t, const FlowNodeIR*> nodeMap;
        for (const auto& n : ir.nodes) {
            nodeMap[n.id] = &n;
        }

        // --- Generate code per node in topological order ---
        int nodeIndex = 0;
        for (uint32_t nodeId : sorted) {
            auto it = nodeMap.find(nodeId);
            if (it == nodeMap.end()) continue;
            const FlowNodeIR& node = *(it->second);
            ++nodeIndex;

            std::string propInfo = GetProperty(node, "stateName");

            out << "    // Node " << node.id << ": " << node.type;
            if (!propInfo.empty()) {
                out << " \"" << propInfo << "\"";
            }
            out << "\n";

            // --- Wire incoming edges ---
            const auto& incoming = incomingEdges[nodeId];
            for (const auto& e : incoming) {
                out << "    // wire: node " << e.fromNode
                    << " port " << e.fromPort << " -> node "
                    << e.toNode << " port " << e.toPort << "\n";
            }

            out << "    {\n";
            EmitNodeCode(out, node, incoming);
            out << "    }\n";
        }

        out << "}\n";
        return out.str();
    }

private:
    // --- Sanitize a name to a valid C++ identifier ---
    static std::string SanitizeName(const std::string& name) {
        std::string result;
        for (char c : name) {
            if (std::isalnum(static_cast<unsigned char>(c)) || c == '_') {
                result += c;
            } else {
                result += '_';
            }
        }
        if (result.empty()) result = "Unnamed";
        return result;
    }

    // --- Look up a property by key ---
    static std::string GetProperty(const FlowNodeIR& node, const std::string& key) {
        for (const auto& kv : node.properties) {
            if (kv.first == key) return kv.second;
        }
        return "";
    }

    // --- Topological sort (Kahn's algorithm) ---
    static std::vector<uint32_t> TopologicalSort(const FlowGraphIR& ir) {
        std::unordered_map<uint32_t, int> inDegree;
        std::unordered_map<uint32_t, std::vector<uint32_t>> adj;

        for (const auto& n : ir.nodes) {
            inDegree[n.id] = 0;
        }
        for (const auto& e : ir.edges) {
            adj[e.fromNode].push_back(e.toNode);
            inDegree[e.toNode]++;
        }

        std::vector<uint32_t> queue;
        for (const auto& n : ir.nodes) {
            if (inDegree[n.id] == 0) {
                queue.push_back(n.id);
            }
        }
        std::sort(queue.begin(), queue.end());

        std::vector<uint32_t> result;
        size_t front = 0;
        while (front < queue.size()) {
            uint32_t cur = queue[front++];
            result.push_back(cur);
            auto adjIt = adj.find(cur);
            if (adjIt != adj.end()) {
                auto neighbors = adjIt->second;
                std::sort(neighbors.begin(), neighbors.end());
                for (uint32_t next : neighbors) {
                    if (--inDegree[next] == 0) {
                        queue.push_back(next);
                    }
                }
            }
        }
        return result;
    }

    // --- Emit C++ code for a single node ---
    static void EmitNodeCode(std::ostringstream& out, const FlowNodeIR& node,
                             const std::vector<FlowEdge>& incoming) {
        uint64_t outKey = static_cast<uint64_t>(node.id) << 16;

        if (node.type == "State") {
            EmitStateNode(out, node, incoming, outKey);
        } else if (node.type == "Condition") {
            EmitConditionNode(out, node, incoming, outKey);
        } else if (node.type == "Timer") {
            EmitTimerNode(out, node, incoming, outKey);
        } else if (node.type == "Transition") {
            EmitTransitionNode(out, node, incoming, outKey);
        } else {
            out << "        // Unknown node type: " << node.type << "\n";
        }
    }

    // --- StateNode: sets active=1.0 if triggered, outputs state name ---
    static void EmitStateNode(std::ostringstream& out, const FlowNodeIR& node,
                              const std::vector<FlowEdge>& incoming, uint64_t outKey) {
        std::string stateName = GetProperty(node, "stateName");
        out << "        float active_" << node.id << " = 1.0f;\n";
        for (const auto& e : incoming) {
            if (e.toPort == 0) {
                uint64_t srcKey = (static_cast<uint64_t>(e.fromNode) << 16) | e.fromPort;
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            active_" << node.id << " = outputs[" << srcKey << "ULL].data[0];\n";
            }
        }
        out << "        outputs[" << outKey << "ULL].data = {active_" << node.id << "};\n";
        out << "        outputs[" << outKey << "ULL].text = \"" << stateName << "\";\n";
    }

    // --- ConditionNode: value >= threshold ? 1.0 : 0.0 ---
    static void EmitConditionNode(std::ostringstream& out, const FlowNodeIR& node,
                                  const std::vector<FlowEdge>& incoming, uint64_t outKey) {
        out << "        float value_" << node.id << " = 0.0f;\n";
        out << "        float threshold_" << node.id << " = 0.5f;\n";
        for (const auto& e : incoming) {
            uint64_t srcKey = (static_cast<uint64_t>(e.fromNode) << 16) | e.fromPort;
            if (e.toPort == 0) {
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            value_" << node.id << " = outputs[" << srcKey << "ULL].data[0];\n";
            } else if (e.toPort == 1) {
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            threshold_" << node.id << " = outputs[" << srcKey << "ULL].data[0];\n";
            }
        }
        out << "        float result_" << node.id << " = (value_" << node.id << " >= threshold_" << node.id << ") ? 1.0f : 0.0f;\n";
        out << "        outputs[" << outKey << "ULL].data = {result_" << node.id << "};\n";
    }

    // --- TimerNode: fires if triggered AND elapsed >= duration ---
    static void EmitTimerNode(std::ostringstream& out, const FlowNodeIR& node,
                              const std::vector<FlowEdge>& incoming, uint64_t outKey) {
        out << "        float duration_" << node.id << " = 1.0f;\n";
        out << "        bool triggered_" << node.id << " = false;\n";
        for (const auto& e : incoming) {
            uint64_t srcKey = (static_cast<uint64_t>(e.fromNode) << 16) | e.fromPort;
            if (e.toPort == 0) {
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            triggered_" << node.id << " = outputs[" << srcKey << "ULL].data[0] > 0.5f;\n";
            } else if (e.toPort == 1) {
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            duration_" << node.id << " = outputs[" << srcKey << "ULL].data[0];\n";
            }
        }
        out << "        float fire_" << node.id << " = (triggered_" << node.id << " && ctx.elapsedTime >= duration_" << node.id << ") ? 1.0f : 0.0f;\n";
        out << "        outputs[" << outKey << "ULL].data = {fire_" << node.id << "};\n";
    }

    // --- TransitionNode: fires trigger if state active AND condition met ---
    static void EmitTransitionNode(std::ostringstream& out, const FlowNodeIR& node,
                                   const std::vector<FlowEdge>& incoming, uint64_t outKey) {
        out << "        bool stateActive_" << node.id << " = false;\n";
        out << "        bool conditionMet_" << node.id << " = false;\n";
        for (const auto& e : incoming) {
            uint64_t srcKey = (static_cast<uint64_t>(e.fromNode) << 16) | e.fromPort;
            if (e.toPort == 0) {
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            stateActive_" << node.id << " = outputs[" << srcKey << "ULL].data[0] > 0.5f;\n";
            } else if (e.toPort == 1) {
                out << "        if (outputs.count(" << srcKey << "ULL) && !outputs[" << srcKey << "ULL].data.empty())\n";
                out << "            conditionMet_" << node.id << " = outputs[" << srcKey << "ULL].data[0] > 0.5f;\n";
            }
        }
        out << "        float trigger_" << node.id << " = (stateActive_" << node.id << " && conditionMet_" << node.id << ") ? 1.0f : 0.0f;\n";
        out << "        outputs[" << outKey << "ULL].data = {trigger_" << node.id << "};\n";
    }
};

} // namespace atlas::flow
